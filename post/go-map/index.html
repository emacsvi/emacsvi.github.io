<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.54.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>go-map | 李伟的博客</title>
    <meta property="og:title" content="go-map - 李伟的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2018-11-23T01:00:15&#43;08:00">
        
        
    <meta property="article:modified_time" content="2018-11-23T01:00:15&#43;08:00">
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,区块链,博客,项目管理,python,软件架构">
    <meta name="description" content="go-map">
        
    <meta name="author" content="emacsvi">
    <meta property="og:url" content="http://emacsvi.com/post/go-map/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://emacsvi.com">
                        李伟的博客
                    </a>
                
                <p class="description">主要专注于区块链、Go语言(golang)、Python、C语言、后端服务架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://emacsvi.com">首页</a>
                    
                    <a  href="http://emacsvi.com/archives/" title="归档">归档</a>
                    
                    <a  href="http://emacsvi.com/about/" title="关于">关于</a>
                    
                    <a  href="http://emacsvi.com/travel/" title="旅行">旅行</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
        
        
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">go-map</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2018年11月23日
                        </date>
                        
                        
                        
                        <div class="post-content">
                            

<h2 id="map概念">map概念</h2>

<p><strong>Go</strong>语言中<code>map</code>是一种特殊的数据结构：一种元素对(<code>pair</code>)的无序集合，<code>pair</code> 的一个元素是<code>key</code>，对应的另一个元素是<code>value</code>，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定<code>key</code>，对应的<code>value</code>可以迅速定位。</p>

<p><code>map</code>这种数据结构在其他编程语言中也称为字典(Python)、<code>hash</code> 和<code>HashTable</code> 等。</p>

<h2 id="map声明和初始化">map声明和初始化</h2>

<p><code>map</code>是引用类型，可以使用如下声明：</p>

<pre><code class="language-go">make(map[KeyType]ValueType, initialCapacity)
make(map[KeyType]ValueType)
map[KeyType]ValueType{}
map[KeyType]ValueType{key1 : value1, key2 : value2, ... , keyN : valueN}
</code></pre>

<p>未初始化的<code>map</code>的值是<code>nil</code>。</p>

<p>用<code>4</code>种方式分别创建数组，其中第一种和第二种的区别在于，有没有指定初始容量，不过使用的时候则无需在意这些，因为map的本质决定了，一旦容量不够，它会自动扩容。示例代码如下:</p>

<pre><code class="language-go">func test1() {
    map1 := make(map[string]string, 5)
    map2 := make(map[string]string)
    map3 := map[string]string{}
    map4 := map[string]string{&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: &quot;2&quot;, &quot;c&quot;: &quot;3&quot;}
    fmt.Println(map1, map2, map3, map4)
}
</code></pre>

<p><strong>注意</strong>：必须要先初始化才能给<code>map</code>赋值设置元素，不然会引起 <code>panic: assign to entry in nil map</code>。</p>

<p><code>Map</code>的键可以是任何值，键的类型可以是内置的类型，也可以是结构类型，但是不管怎么样，这个键可以使用<code>==</code>运算符进行比较，所以像切片、函数以及含有切片的结构类型就不能用于<code>Map</code>的键了，因为他们具有引用的语义，不可比较。</p>

<p>对于<code>Map</code>的值来说，就没有什么限制了，切片这种在键里不能用的，完全可以用在值里。</p>

<pre><code class="language-go">func main(){
    ages01 := map[string]int{
        &quot;alice&quot;:31,
        &quot;bob&quot;:13,
    }
    ages02 := make(map[string]int)
    ages02[&quot;chris&quot;] =20
    ages02[&quot;paul&quot;] = 30
    //age01和age02两种初始化的方式等价

    m1 := make(map[string]int)
    m2 := map[string]int{}
    //m1和m2创建方式等价，都是创建了一个空的的map，这个时候m1和m2没有任何元素

    for name,age := range ages01{
        fmt.Printf(&quot;%s\t%d\n&quot;,name,age)
    }
    for name,age := range ages02{
        fmt.Printf(&quot;%s\t%d\n&quot;,name,age)
    }
    var null_map map[string]int     //声明但未初始化map，此时是map的零值状态（只有一个nil元素）
    empty_map := map[string]int{}   //创建了初始化了一个空的的map，这个时候empty_map没有任何元素
    fmt.Println(m1 != nil &amp;&amp; m2 != nil) //true
    fmt.Println(len(null_map)==0)
    fmt.Println(null_map ==nil)     //true,此时是map的零值状态(nil)
    fmt.Println(len(empty_map)==0)
    fmt.Println(empty_map ==nil)     //false,空的的map不等价于nil(map的零值状态)
    empty_map[&quot;test&quot;] = 12           //执行正常，空的的map可以赋值设置元素
    null_map[&quot;test&quot;] = 12            //panic: assignment to entry in nil map，无法给未初始化的map赋值设置元素
}
</code></pre>

<h2 id="map元素遍历">map元素遍历</h2>

<p><code>range for</code>可用于遍历<code>map</code>中所有的元素，不过需要注意因为<code>map</code>本身是无序的，因此对于程序的每次执行，不能保证使用<code>range for</code>遍历<code>map</code>的顺序总是一致的。例如：</p>

<pre><code class="language-go">func main() {  
    personSalary := map[string]int{
        &quot;steve&quot;: 12000,
        &quot;jamie&quot;: 15000,
    }
    personSalary[&quot;mike&quot;] = 9000
    fmt.Println(&quot;All items of a map&quot;)
    for key, value := range personSalary {
        fmt.Printf(&quot;personSalary[%s] = %d\n&quot;, key, value)
    }
}
</code></pre>

<h2 id="map元素增删改查">map元素增删改查</h2>

<p>首先这里<code>map</code>元素的增加和修改元素的语法一致，只需要<code>map[K]=V</code>即可。例如：</p>

<pre><code class="language-go">func main() {
    personSalary := make(map[string]int)
    personSalary[&quot;steve&quot;] = 12000     //增加元素
    personSalary[&quot;jamie&quot;] = 15000    //增加元素
    personSalary[&quot;mike&quot;] = 9000       //增加元素
    fmt.Println(&quot;map before change&quot;, personSalary)
    personSalary[&quot;mike&quot;] = 10000    //修改元素
    fmt.Println(&quot;map after change&quot;, personSalary)
}
//output
/*
map before change map[steve:12000 jamie:15000 mike:9000]
map after change map[steve:12000 jamie:15000 mike:10000]
*/
</code></pre>

<p>删除元素需要使用内置函数<code>delete</code>，该函数根据键来删除一个元素。需要强调<code>delete</code>函数没有返回值，<code>delete</code>函数删除不存在的键也是可以的，只是没有任何作用。例如：</p>

<pre><code class="language-go">func main() {  
    personSalary := map[string]int{
        &quot;steve&quot;: 12000,
        &quot;jamie&quot;: 15000,
    }
    personSalary[&quot;mike&quot;] = 9000
    fmt.Println(&quot;map before deletion&quot;, personSalary)
    delete(personSalary, &quot;steve&quot;)
    fmt.Println(&quot;map after deletion&quot;, personSalary)
}
//output
/*
map before deletion map[steve:12000 jamie:15000 mike:9000]  
map after deletion map[mike:9000 jamie:15000] 
*/
</code></pre>

<p>查找<code>map</code>中某个元素需要用下面的代码段：</p>

<pre><code class="language-go">if _, ok := map[key]; ok {  
//如果存在则执行  
} 
</code></pre>

<p>这里需要强调下，根据键值索引某个元素时，也会返回两个值：索引到的值和本次索引是否成功(这里可能会因为索数值越界或者索引键值有误而导致索引失败)。</p>

<p>示例代码如下：</p>

<pre><code class="language-go">func main(){
    ages01 := map[string]int{
        &quot;alice&quot;:31,
        &quot;bob&quot;:13,
    }

    age, ok := ages01[&quot;bo&quot;]   //age才是根据键值索引到的值
    if !ok{
        fmt.Printf(&quot;索引失败，bo不是map的键值，此时age=%d&quot;,age)  //索引失败会返回value的零值，这里是int类型，所以是0
    } else {
        fmt.Printf(&quot;索引成功，age=%d&quot;,age)
    }
}
</code></pre>

<h2 id="map的不可比性">map的不可比性</h2>

<p><code>Go</code>语言中<code>map</code>和<code>slice</code>，<code>func</code>一样，不支持<code>==</code>操作符，就是不能直接比较。唯一合法的就是和<code>nil</code>作比较，判断该<code>map</code>是不是零值状态。</p>

<p>如果想自定义一个函数，来比较两个<code>map</code>是否相等，就可以遍历比较它们的键和值是否完全相等，代码如下：</p>

<pre><code class="language-go">func map_equal(x,y map[string] string) bool {
    if (len(x)) != len(y) {
      return false
    }
    for k, xv := range x {
      if yv, ok:=y[k]; !ok || yv!=xv{
            return false
        }
    }
    return true
}
</code></pre>

<h2 id="查找键值">查找键值</h2>

<p>检查一个<code>map</code>中是否有某一个<code>key</code>，使用一个惯用的写法：</p>

<pre><code class="language-go">if v, ok := argsMap[&quot;key1&quot;]; ok {
    fmt.Println(&quot;key1:&quot;, v)
}
</code></pre>

<p><code>argsMap[&quot;key1&quot;]</code>表达式多重返回</p>

<ul>
<li><code>v</code>是<code>value</code>的值(如果<code>key</code>能够找到)，如果单纯判断<code>key</code>，并不需要<code>value</code>，可以用占位符<code>_</code>占位</li>
<li><code>ok</code>是<code>bool</code>类型值，如果<code>key</code>能够找到，其为<code>true</code>，否则是<code>false</code></li>
<li><code>if</code>语句通过<code>ok</code>的结果决定是否进入花括号中。</li>
</ul>

<h2 id="多维map的坑">多维map的坑</h2>

<p>在自己的项目里用到了一个二维<code>map</code>，结果第一遍写的时候就碰到了那个<code>nil map</code>的问题。
一开始的代码是这样的：</p>

<pre><code class="language-go">m := make(map[string]map[string]string)
m[&quot;a&quot;][&quot;b&quot;] = &quot;ccc&quot;
</code></pre>

<p>后来才想明白如果插新加入的元素也是个<code>map</code>的话需要再次<code>make()</code>!! 修正后的代码如下</p>

<pre><code class="language-go">m := make(map[string]map[string]int)
c := make(map[string]int)
c[&quot;b&quot;] = 1
m[&quot;a&quot;] = c
</code></pre>

<p>这时的<code>m[&quot;a&quot;]</code>的值就是另一个<code>map</code>了.</p>

<p>多维度<code>Map</code>的数据存取
一维情况下的<code>map</code>做存取很简单，而二维以上的情况就得小心了. 先来看一个例子：</p>

<pre><code class="language-go">m := make(map[string]map[string]int)
c := make(map[string]int)
c[&quot;b&quot;] = 1
m[&quot;a&quot;] = c
d := make(map[string]int)
d[&quot;c&quot;] = 2
m[&quot;a&quot;] = d
</code></pre>

<p>而这个时候再去查询<code>m[&quot;a&quot;][&quot;b&quot;]</code>会发现这个值已经没有了，取而代之的是<code>m[&quot;a&quot;][&quot;c&quot;]</code>.
这是因为<code>b</code>和<code>c</code>都是<code>map[string]int</code>类型的数据，<code>Golang</code> 直接把<code>[&quot;a&quot;]</code>里的数据从<code>b</code>替换成了<code>c</code>，而不会递归地添加<code>map</code>中缺失的数据。
要在<code>m</code>中保留<code>[&quot;a&quot;][&quot;b&quot;]</code>和<code>[&quot;a&quot;][&quot;c&quot;]</code>，需要一些额外的判断才行：</p>

<pre><code class="language-go">if _, exist := m[&quot;a&quot;]; exist {
    m[&quot;a&quot;][&quot;c&quot;] = 2
} else {
    c := make(map[string]int)
    c[&quot;c&quot;] = 2
    m[&quot;a&quot;] = c
}
</code></pre>

<p>换句话说，每次创建一个一维<code>map</code>都要<code>make()</code>一次，不然就会<code>panic</code>. 多维<code>map</code>没加一层都要多<code>make()</code>好几次.</p>

<h2 id="map排序">map排序</h2>

<p>如果想按顺序遍历，可以先对<code>Map</code>中的键排序，然后遍历排序好的键，把对应的值取出来，下面看个例子就明白了。</p>

<pre><code class="language-go">func main() {
	dict := map[string]int{&quot;王五&quot;: 60, &quot;张三&quot;: 43}
	var names []string
	for name := range dict {
		names = append(names, name)
	}
	sort.Strings(names) //排序
	for _, key := range names {
		fmt.Println(key, dict[key])
	}
}
</code></pre>

<p>这个例子里有个技巧，<code>range</code> 一个<code>Map</code>的时候，也可以使用一个返回值，这个默认的返回值就是Map的键。</p>

<h2 id="map并发">map并发</h2>

<p>哈希表在有并发的场景并不安全：同时读写一个哈希表的后果是不确定的。如果你需要使用<code>goroutines</code>同时对一个哈希表做读写，对哈希表的访问需要通过某种同步机制做协调。一个常用的方法是是使用 <code>sync.RWMutex</code>。</p>

<p>这个语句声明了一个<code>counter</code>变量，这是一个包含了一个map和sync.RWMutex的匿名结构体。</p>

<pre><code class="language-go">var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}
</code></pre>

<p>读<code>counter</code>前，获取读锁：</p>

<pre><code class="language-go">counter.RLock()
n := counter.m[&quot;some_key&quot;]
counter.RUnlock()
fmt.Println(&quot;some_key:&quot;, n)
</code></pre>

<p>写counter前，获取写锁</p>

<pre><code class="language-go">counter.Lock()
counter.m[&quot;some_key&quot;]++
counter.Unlock()
</code></pre>

<p>对应与<strong>sync.Map</strong>的使用接口示例：</p>

<pre><code class="language-go">package RegularIntMap

type RegularIntMap struct {
	sync.RWMutex
	internal map[int]int
}

func NewRegularIntMap() *RegularIntMap {
	return &amp;RegularIntMap{
		internal: make(map[int]int),
	}
}

func (rm *RegularIntMap) Load(key int) (value int, ok bool) {
	rm.RLock()
	result, ok := rm.internal[key]
	rm.RUnlock()
	return result, ok
}

func (rm *RegularIntMap) Delete(key int) {
	rm.Lock()
	delete(rm.internal, key)
	rm.Unlock()
}

func (rm *RegularIntMap) Store(key, value int) {
	rm.Lock()
	rm.internal[key] = value
	rm.Unlock()
}
</code></pre>

<h1 id="sync-map使用">sync.Map使用</h1>

<p>从go1.9开始，sync.Map提供给大家使用，线性安全的map操作。</p>

<pre><code class="language-go">// 说明： 存储一个设置的键值。
Store(key, value interface{})

// 说明： 返回键的现有值(如果存在)，否则存储并返回给定的值，如果是读取则返回true，如果是存储返回false。
LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)

// 说明： 读取存储在map中的值，如果没有值，则返回nil。OK的结果表示是否在map中找到值。
Load(key interface{}) (value interface{}, ok bool)

// 说明： 删除键对应的值。
Delete(key interface{})

// 说明： 循环读取map中的值。
Range(f func(key, value interface{}) bool)
</code></pre>

<p>因为<code>for ... range map</code>是内建的语言特性，所以没有办法使用<code>for range</code>遍历<code>sync.Map</code>, 但是可以使用它的<strong>Range</strong>方法，通过回调的方式遍历。</p>

<p>示例代码：</p>

<pre><code class="language-go">type userInfo struct {
    Name string
    Age  int
}
var m sync.Map
func main() {
    vv, ok := m.LoadOrStore(&quot;1&quot;, &quot;one&quot;)
    fmt.Println(vv, ok) //one false

    vv, ok = m.Load(&quot;1&quot;)
    fmt.Println(vv, ok) //one true

    vv, ok = m.LoadOrStore(&quot;1&quot;, &quot;oneone&quot;)
    fmt.Println(vv, ok) //one true

    vv, ok = m.Load(&quot;1&quot;)
    fmt.Println(vv, ok) //one true

    m.Store(&quot;1&quot;, &quot;oneone&quot;)
    vv, ok = m.Load(&quot;1&quot;)
    fmt.Println(vv, ok) // oneone true

    m.Store(&quot;2&quot;, &quot;two&quot;)
    m.Range(func(k, v interface{}) bool {
      fmt.Println(k, v)
      return true
    })

    m.Delete(&quot;1&quot;)
    m.Range(func(k, v interface{}) bool {
      fmt.Println(k, v)
      return true
    })

    map1 := make(map[string]userInfo)
    var user1 userInfo
    user1.Name = &quot;ChamPly&quot;
    user1.Age = 24
    map1[&quot;user1&quot;] = user1

    var user2 userInfo
    user2.Name = &quot;Tom&quot;
    user2.Age = 18
    m.Store(&quot;map_test&quot;, map1)

    mapValue, _ := m.Load(&quot;map_test&quot;)

    for k, v := range mapValue.(interface{}).(map[string]userInfo) {
      fmt.Println(k, v)
      fmt.Println(&quot;name:&quot;, v.Name)
    }
}
</code></pre>

<h2 id="性能测试">性能测试</h2>

<p>代码结构：</p>

<pre><code class="language-shell"> ~/coding/go/sync-map-analysis 
.
├── LICENSE
├── README.md
├── bench_test.go
├── main.go
└── regular.go
</code></pre>

<p>regular.go</p>

<pre><code class="language-go">package main

import (
	&quot;sync&quot;
)

type RegularStringMap struct {
	sync.RWMutex
	internal map[string]string
}

func NewRegularStringMap() *RegularStringMap {
	return &amp;RegularStringMap{
		internal: make(map[string]string),
	}
}

func (rm *RegularStringMap) Load(key string) (value string, ok bool) {
	rm.RLock()
	result, ok := rm.internal[key]
	rm.RUnlock()
	return result, ok
}

func (rm *RegularStringMap) Delete(key string) {
	rm.Lock()
	delete(rm.internal, key)
	rm.Unlock()
}

func (rm *RegularStringMap) Store(key, value string) {
	rm.Lock()
	rm.internal[key] = value
	rm.Unlock()
}

type RegularIntMap struct {
	sync.RWMutex
	internal map[int]int
}

func NewRegularIntMap() *RegularIntMap {
	return &amp;RegularIntMap{
		internal: make(map[int]int),
	}
}

func (rm *RegularIntMap) Load(key int) (value int, ok bool) {
	rm.RLock()
	result, ok := rm.internal[key]
	rm.RUnlock()
	return result, ok
}

func (rm *RegularIntMap) Delete(key int) {
	rm.Lock()
	delete(rm.internal, key)
	rm.Unlock()
}

func (rm *RegularIntMap) Store(key, value int) {
	rm.Lock()
	rm.internal[key] = value
	rm.Unlock()
}
</code></pre>

<p>main.go</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
)

func main() {
	regularMapUsage()
	syncMapUsage()
}

func regularMapUsage() {
	fmt.Println(&quot;Regular threatsafe map test&quot;)
	fmt.Println(&quot;---------------------------&quot;)

	// Create the threadsafe map.
	reg := NewRegularStringMap()

	// Fetch an item that doesn't exist yet.
	result, ok := reg.Load(&quot;hello&quot;)
	if ok {
		fmt.Println(result)
	} else {
		fmt.Println(&quot;value not found for key: `hello`&quot;)
	}

	// Store an item in the map.
	reg.Store(&quot;hello&quot;, &quot;world&quot;)
	fmt.Println(&quot;added value: `world` for key: `hello`&quot;)

	// Fetch the item we just stored.
	result, ok = reg.Load(&quot;hello&quot;)
	if ok {
		fmt.Printf(&quot;result: `%s` found for key: `hello`\n&quot;, result)
	}

	fmt.Println(&quot;---------------------------&quot;)
	fmt.Println()
	fmt.Println()
}

func syncMapUsage() {
	fmt.Println(&quot;sync.Map test (Go 1.9+ only)&quot;)
	fmt.Println(&quot;----------------------------&quot;)

	// Create the threadsafe map.
	var sm sync.Map

	// Fetch an item that doesn't exist yet.
	result, ok := sm.Load(&quot;hello&quot;)
	if ok {
		fmt.Println(result)
	} else {
		fmt.Println(&quot;value not found for key: `hello`&quot;)
	}

	// Store an item in the map.
	sm.Store(&quot;hello&quot;, &quot;world&quot;)
	fmt.Println(&quot;added value: `world` for key: `hello`&quot;)

	// Fetch the item we just stored.
	result, ok = sm.Load(&quot;hello&quot;)
	if ok {
		fmt.Printf(&quot;result: `%s` found for key: `hello`\n&quot;, result.(string))
	}

	fmt.Println(&quot;---------------------------&quot;)
}
</code></pre>

<h2 id="参考文献">参考文献</h2>

<ul>
<li><a href="https://blog.csdn.net/xiangxianghehe/article/details/78790744">go复合数据结构之map</a></li>
<li><a href="https://blog.csdn.net/guanchunsheng/article/details/79615591">map 查</a></li>
<li><a href="http://www.cnblogs.com/igloo1986/p/3546337.html">map并发</a></li>
<li><a href="http://colobu.com/2017/07/11/dive-into-sync-Map/">sync.Map</a></li>
<li><a href="http://www.nljb.net/default/Golang%E4%B9%8Bv1.9%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84sync.Map/">Golang之v1.9中线程安全的sync.Map</a></li>
<li><a href="https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c">sync.Map 与 map RWMutex</a></li>
<li><a href="https://github.com/deckarep/sync-map-analysis">性能测试示例代码 github</a></li>
</ul>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/go-ipfs-compile/">ipfs编译问题</a></li>
        
        <li><a href="/post/jetbrain%E5%AE%B6%E6%97%8Fgoland-pycharm-webstorm%E9%85%8D%E7%BD%AE/">jetbrains</a></li>
        
        <li><a href="/post/emacsvi-awesome-go/">备忘go语言常用的库</a></li>
        
        <li><a href="/post/go-time-after/">go-time.After释放</a></li>
        
        <li><a href="/post/go-select/">go-select使用误区</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="http://emacsvi.com/tags/go">go</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://emacsvi.com">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://emacsvi.com/post/kubeadm-kubernetes/" title="利用kubeadm部署kubernetes">利用kubeadm部署kubernetes</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/centos7-system-notes/" title="centos7系统配置">centos7系统配置</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/vagrant-notes/" title="vagrant相关配置命令">vagrant相关配置命令</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/heling-go-36-notes/" title="赫林老师go语言36讲">赫林老师go语言36讲</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/frp/" title="frp内网穿透">frp内网穿透</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/harbor-image-notes/" title="harbor镜像仓库搭建">harbor镜像仓库搭建</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/dynamic-json-in-go/" title="Dynamic Json In Go">Dynamic Json In Go</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/my-go-codes/" title="go常用的一些代码备忘">go常用的一些代码备忘</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-keng-notes/" title="go语言编码过程中常见的坑总结">go语言编码过程中常见的坑总结</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-websocket-practice/" title="websocket实践">websocket实践</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://emacsvi.com/categories/blockchain/">blockchain(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/consul/">consul(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/db/">db(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/docker/">docker(2)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/etcd/">etcd(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/ethereum/">ethereum(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/go/">go(30)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/kubernetes/">kubernetes(2)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/linux/">linux(4)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/mac/">mac(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/markdown/">markdown(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/nodejs/">nodejs(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/python/">python(10)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/react/">react(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/redis/">redis(2)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/%E6%8A%80%E6%9C%AF/">技术(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/%E6%97%85%E8%A1%8C/">旅行(3)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/%E6%B5%81%E9%87%91%E5%B2%81%E6%9C%88/">流金岁月(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="http://emacsvi.com/tags/Istio/">Istio</a>
    
    <a href="http://emacsvi.com/tags/blockchain/">blockchain</a>
    
    <a href="http://emacsvi.com/tags/cmds/">cmds</a>
    
    <a href="http://emacsvi.com/tags/codis/">codis</a>
    
    <a href="http://emacsvi.com/tags/consul/">consul</a>
    
    <a href="http://emacsvi.com/tags/curl/">curl</a>
    
    <a href="http://emacsvi.com/tags/db/">db</a>
    
    <a href="http://emacsvi.com/tags/django/">django</a>
    
    <a href="http://emacsvi.com/tags/docker/">docker</a>
    
    <a href="http://emacsvi.com/tags/docker-compose/">docker-compose</a>
    
    <a href="http://emacsvi.com/tags/etcd/">etcd</a>
    
    <a href="http://emacsvi.com/tags/ethereum/">ethereum</a>
    
    <a href="http://emacsvi.com/tags/go/">go</a>
    
    <a href="http://emacsvi.com/tags/javascript/">javascript</a>
    
    <a href="http://emacsvi.com/tags/kubernetes/">kubernetes</a>
    
    <a href="http://emacsvi.com/tags/linux/">linux</a>
    
    <a href="http://emacsvi.com/tags/mac/">mac</a>
    
    <a href="http://emacsvi.com/tags/markdown/">markdown</a>
    
    <a href="http://emacsvi.com/tags/mongodb/">mongodb</a>
    
    <a href="http://emacsvi.com/tags/mysql/">mysql</a>
    
    <a href="http://emacsvi.com/tags/nodejs/">nodejs</a>
    
    <a href="http://emacsvi.com/tags/python/">python</a>
    
    <a href="http://emacsvi.com/tags/react/">react</a>
    
    <a href="http://emacsvi.com/tags/redis/">redis</a>
    
    <a href="http://emacsvi.com/tags/selenium/">selenium</a>
    
    <a href="http://emacsvi.com/tags/sql/">sql</a>
    
    <a href="http://emacsvi.com/tags/supervisord/">supervisord</a>
    
    <a href="http://emacsvi.com/tags/vagrant/">vagrant</a>
    
    <a href="http://emacsvi.com/tags/websocket/">websocket</a>
    
    <a href="http://emacsvi.com/tags/%E5%A4%87%E5%BF%98/">备忘</a>
    
    <a href="http://emacsvi.com/tags/%E6%8A%80%E6%9C%AF/">技术</a>
    
    <a href="http://emacsvi.com/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    
    <a href="http://emacsvi.com/tags/%E7%88%AC%E8%99%AB/">爬虫</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="#" title="Android Gradle权威指南">Android Gradle权威指南</a>
        </li>
        
        <li>
            <a target="_blank" href="#" title="常用开发工具CDN镜像">常用开发工具CDN镜像</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://emacsvi.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="http://emacsvi.com">李伟的博客 By emacsvi</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.emacsvi.com/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        
        (function () {
            $("pre code").parent().addClass("line-numbers")
        }());

        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>







</body>
</html>
