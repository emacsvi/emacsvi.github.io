<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.54.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>go的数组与切片 | 李伟的博客</title>
    <meta property="og:title" content="go的数组与切片 - 李伟的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2018-11-23T01:00:01&#43;08:00">
        
        
    <meta property="article:modified_time" content="2018-11-23T01:00:01&#43;08:00">
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,区块链,博客,项目管理,python,软件架构">
    <meta name="description" content="go的数组与切片">
        
    <meta name="author" content="emacsvi">
    <meta property="og:url" content="http://emacsvi.com/post/go-array-slice/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://emacsvi.com">
                        李伟的博客
                    </a>
                
                <p class="description">主要专注于区块链、Go语言(golang)、Rust, Java, Python、C语言、后端服务架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://emacsvi.com">首页</a>
                    
                    <a  href="http://emacsvi.com/archives/" title="归档">归档</a>
                    
                    <a  href="http://emacsvi.com/about/" title="关于">关于</a>
                    
                    <a  href="http://emacsvi.com/travel/" title="旅行">旅行</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
        
        
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">go的数组与切片</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2018年11月23日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="http://emacsvi.com/categories/go">go</a></span>
                            
                        </div>
                        
                        
                        
                        <div class="post-content">
                            

<h2 id="数据与切片">数据与切片</h2>

<p>声明一个数组和一个切片是不同的。</p>

<pre><code class="language-go">var arr [5]int
arr := [5]int{1,2,3,4,5 }

var sli []int
sli := []int{1,2,3,4,5}
</code></pre>

<p>请看完下面</p>

<h3 id="数组">数组：</h3>

<p><code>Go</code>的切片是在数组之上的抽象数据类型，因此在了解切片之前必须要先理解数组。</p>

<p>数组类型定义了长度和元素类型。例如， <code>[4]int</code> 类型表示一个四个整数的数组。 数组的长度是固定的，长度是数组类型的一部分(<code>[4]int</code> 和 <code>[5]int</code> 是完全不同的类型)。 数组可以以常规的索引方式访问，表达式 <code>s[n]</code> 访问数组的第 <code>n</code> 个元素。</p>

<pre><code class="language-go">var a [4]int
a[0] = 1
i := a[0]
// i == 1
</code></pre>

<p>数组不需要显式的初始化；数组的零值是可以直接使用的，数组元素会自动初始化为其对应类型的零值：</p>

<pre><code class="language-go">// a[2] == 0, int 类型的零值
</code></pre>

<p>类型 [4]int 对应内存中四个连续的整数</p>

<p><code>Go</code>的数组是值语义。一个数组变量表示整个数组，<strong>它不是指向第一个元素的指针</strong>(不像 C 语言的数组)。 当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。 (为了避免复制数组，你可以传递一个指向数组的指针，但是数组指针并不是数组。) 可以将数组看作一个特殊的<code>struct</code>，结构的字段名对应数组的索引，同时成员的数目固定。</p>

<p>数组的字面值像这样：</p>

<pre><code class="language-go">b := [2]string{&quot;Penn&quot;, &quot;Teller&quot;}
</code></pre>

<p>当然，也可以让编译器统计数组字面值中元素的数目：</p>

<pre><code class="language-go">b := [...]string{&quot;Penn&quot;, &quot;Teller&quot;}
</code></pre>

<p>这两种写法， b 都是对应 <code>[2]string</code> 类型。</p>

<h3 id="数据声明">数据声明：</h3>

<pre><code class="language-go">ArrayType   = &quot;[&quot; ArrayLength &quot;]&quot; ElementType .
// 例如：
var a [32] int
var b [3][5] int
</code></pre>

<p>在<code>Go</code>和<code>C</code>中，数组的工作方式有几个重要的差别。在<code>Go</code>中:
- 数组是值类型。将一个数组赋值给另一个，会拷贝所有的元素。
- 如果你给函数传递一个数组，其将收到一个数组的拷贝，而不是它的指针。
- 数组的<strong>大小是其类型的一部分</strong>，类型<code>[10]int</code>和<code>[20]int</code>是不同的。数组长度在声明后，就不可更改。</p>

<p><strong>数组</strong>在初始化后长度是固定的，无法修改其长度。当作为方法的入参传入时将<strong>复制一份数组</strong>而不是引用同一指针。数组的<strong>长度也是其类型的一部分</strong>，通过内置函数<code>len(array)</code>获取其长度。</p>

<p>示例：</p>

<pre><code class="language-go">// 长度为5的数组，其元素值依次为：1，2，3，4，5
[5] int {1,2,3,4,5} 

// 长度为5的数组，其元素值依次为：1，2，0，0，0 。在初始化时没有指定初值的元素将会赋值为其元素类型int的默认值0,string的默认值是&quot;&quot;
[5] int {1,2} 

// 长度为5的数组，其长度是根据初始化时指定的元素个数决定的
[...] int {1,2,3,4,5} 

// 长度为5的数组，key:value,其元素值依次为：0，0，1，2，3。在初始化时指定了2，3，4索引中对应的值：1，2，3
[5] int { 2:1,3:2,4:3} 

// 长度为5的数组，起元素值依次为：0，0，1，0，3。由于指定了最大索引4对应的值3，根据初始化的元素个数确定其长度为5
[...] int {2:1,4:3} 

// 数组通过下标访问元素，可修改其元素值
arr :=[...] int {1,2,3,4,5}
arr[4]=arr[1]+len(arr)      //arr[4]=2+5

// 数组是值类型，将一个数组赋值给另一个数组时将复制一份新的元素
arr2 := [5]int{1, 2} 
arr5 := arr2
arr5[0] = 5
arr2[4] = 2
fmt.Printf(&quot; arr5= %d \n arr2=%d \n arr5[0]==arr2[0]= %s \n&quot;, arr5, arr2, arr5[0] == arr2[0])

/*OutPut:
 arr5=[5 2 0 0 0] 
 arr2=[1 2 0 0 2] 
 arr5[0]==arr2[0]= false
 */
</code></pre>

<h3 id="切片">切片</h3>

<p>切片类型的写法是<code>[]T</code> ， <code>T</code> 是切片元素的类型。和数组不同的是，切片类型并没有给定固定的长度。</p>

<p>切片的字面值和数组字面值很像，不过切片没有指定元素个数：</p>

<pre><code class="language-go">letters := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
</code></pre>

<p>切片可以使用内置函数 <code>make</code> 创建，函数签名为：</p>

<pre><code class="language-go">func make([]T, len, cap) []T
</code></pre>

<p>其中<code>T</code>代表被创建的切片元素的类型。函数 <code>make</code> 接受一个类型、一个长度和一个可选的容量参数。 调用<code>make</code>时，内部会分配一个数组，然后返回数组对应的切片。</p>

<pre><code class="language-go">var s []byte
s = make([]byte, 5, 5)
// s == []byte{0, 0, 0, 0, 0}
</code></pre>

<p>当容量参数被忽略时，它默认为指定的长度。下面是简洁的写法：</p>

<pre><code class="language-go">s := make([]byte, 5)
</code></pre>

<p>可以使用内置函数<code>len</code>和<code>cap</code>获取切片的长度和容量信息。</p>

<pre><code class="language-go">len(s) == 5
cap(s) == 5
</code></pre>

<p>接下来的两个小节将讨论长度和容量之间的关系。</p>

<p><strong>切片的零值为 nil 。对于切片的零值， len 和 cap 都将返回0。</strong></p>

<p>切片也可以<strong>基于现有的切片或数组生成</strong>。切分的范围由两个由冒号分割的索引对应的半开区间指定。 例如，表达式<code>b[1:4]</code>创建的切片引用数组<code>b</code>的第<code>1</code>到<code>3</code>个元素空间（对应切片的索引为<code>0</code>到<code>2</code>）。</p>

<pre><code class="language-go">b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b
</code></pre>

<p>切片的开始和结束的索引都是可选的；它们分别默认为零和数组的长度。</p>

<pre><code class="language-go">// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
</code></pre>

<p>下面语法也是基于数组创建一个切片：</p>

<pre><code class="language-go">x := [3]string{&quot;Лайка&quot;, &quot;Белка&quot;, &quot;Стрелка&quot;}
s := x[:] // a slice referencing the storage of x
</code></pre>

<h3 id="切片的内幕">切片的内幕</h3>

<p>一个切片是一个数组片段的描述。它包含了指向<strong>数组的指针</strong>，<strong>片段的长度</strong>， 和<strong>容量(片段的最大长度)</strong>。</p>

<p><img src="/images/slice01.png" alt="slice01" /></p>

<p>前面使用<code>make([]byte, 5)</code>创建的切片变量<code>s</code>的结构如下：</p>

<p><img src="/images/slice02.png" alt="slice02" /></p>

<p>长度是切片引用的元素数目。容量是底层数组的元素数目(从切片指针开始)。 关于长度和容量和区域将在下一个例子说明。</p>

<p>我们继续对<code>s</code>进行切片，观察切片的数据结构和它引用的底层数组：</p>

<pre><code class="language-go">s = s[2:4]
</code></pre>

<p><img src="/images/slice03.png" alt="slice03" /></p>

<p>切片操作并不复制切片指向的元素。它创建一个新的切片并复用原来切片的底层数组。 这使得切片操作和数组索引一样高效。因此，通过一个新切片修改元素会影响到原始切片的对应元素。</p>

<pre><code class="language-go">d := []byte{'r', 'o', 'a', 'd'}
e := d[2:] 
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
</code></pre>

<p>前面创建的切片<code>s</code>长度小于它的容量。我们可以增长切片的长度为它的容量：</p>

<pre><code class="language-go">s = s[:cap(s)]
</code></pre>

<p><img src="/images/slice04.png" alt="slice04" /></p>

<p>切片增长不能超出其容量。增长超出切片容量将会导致运行时异常，就像切片或数组的索引超 出范围引起异常一样。同样，不能使用小于零的索引去访问切片之前的元素。</p>

<h3 id="切片的生长-copy-and-append-函数">切片的生长（copy and append 函数）</h3>

<p>要增加切片的容量必须创建一个新的、更大容量的切片，然后将原有切片的内容复制到新的切片。 整个技术是一些支持动态数组语言的常见实现。下面的例子将切片<code>s</code>容量翻倍，先创建一个<code>2倍</code> 容量的新切片<code>t</code>，复制<code>s</code>的元素到<code>t</code>，然后将<code>t</code>赋值给<code>s</code>：</p>

<pre><code class="language-go">t := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0
for i := range s {
  t[i] = s[i]
}
s = t
</code></pre>

<p>循环中复制的操作可以由<code>copy</code>内置函数替代。<code>copy</code>函数将源切片的元素复制到目的切片。 它返回复制元素的数目。</p>

<pre><code class="language-go">func copy(dst, src []T) int
</code></pre>

<p><code>copy</code>函数支持不同长度的切片之间的复制（它只复制较短切片的长度个元素）。 此外，<code>copy</code>函数可以正确处理源和目的切片有重叠的情况。</p>

<p>使用<code>copy</code>函数，我们可以简化上面的代码片段：</p>

<pre><code class="language-go">t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
</code></pre>

<p>一个常见的操作是将数据追加到切片的尾部。下面的函数将元素追加到切片尾部， 必要的话会增加切片的容量，最后返回更新的切片：</p>

<pre><code class="language-go">func AppendByte(slice []byte, data ...byte) []byte {
    m := len(slice)
    n := m + len(data)
    if n &gt; cap(slice) { // if necessary, reallocate
        // allocate double what's needed, for future growth.
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n]
    copy(slice[m:n], data)
    return slice
}
</code></pre>

<p>下面是<code>AppendByte</code>的一种用法：</p>

<pre><code class="language-go">p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
</code></pre>

<p>类似<code>AppendByte</code>的函数比较实用，因为它提供了切片容量增长的完全控制。 根据程序的特点，可能希望分配较小的活较大的块，或则是超过某个大小再分配。</p>

<p>但大多数程序不需要完全的控制，因此<code>Go</code>提供了一个内置函数<code>append</code>， 用于大多数场合；它的函数签名：</p>

<pre><code class="language-go">func append(s []T, x ...T) []T
</code></pre>

<p><code>append</code>函数将<code>x</code>追加到切片<code>s</code>的末尾，并且在必要的时候增加容量。</p>

<pre><code class="language-go">a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
</code></pre>

<p>如果是要将一个切片追加到另一个切片尾部，需要使用<code>...</code>语法将第2个参数展开为参数列表。</p>

<pre><code class="language-go">a := []string{&quot;John&quot;, &quot;Paul&quot;}
b := []string{&quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
a = append(a, b...) // equivalent to &quot;append(a, b[0], b[1], b[2])&quot;
// a == []string{&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
</code></pre>

<p>由于切片的零值<code>nil</code>用起来就像一个长度为零的切片，我们可以声明一个切片变量然后在循环 中向它追加数据：</p>

<pre><code class="language-go">// Filter returns a new slice holding only
// the elements of s that satisfy f()
func Filter(s []int, fn func(int) bool) []int {
    var p []int // == nil
    for _, v := range s {
        if fn(v) {
            p = append(p, v)
        }
    }
    return p
}
</code></pre>

<h3 id="可能的-陷阱">可能的“陷阱”</h3>

<p>正如前面所说，切片操作并不会复制底层的数组。整个数组将被保存在内存中，直到它不再被引用。 有时候可能会因为一个小的内存引用导致保存所有的数据。</p>

<p>例如，<code>FindDigits</code>函数加载整个文件到内存，然后搜索第一个连续的数字，最后结果以切片方式返回。</p>

<pre><code class="language-go">var digitRegexp = regexp.MustCompile(&quot;[0-9]+&quot;)

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
</code></pre>

<p>这段代码的行为和描述类似，返回的<code>[]byte</code>指向保存整个文件的数组。因为切片引用了原始的数组， 导致<code>GC</code>不能释放数组的空间；只用到少数几个字节却导致整个文件的内容都一直保存在内存里。</p>

<p>要修复整个问题，可以将感兴趣的数据复制到一个新的切片中：</p>

<pre><code class="language-go">func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    c := make([]byte, len(b))
    copy(c, b)
    return c
}
</code></pre>

<p>可以使用 append 实现一个更简洁的版本。这留给读者作为练习。</p>

<h3 id="切片声明">切片声明：</h3>

<p>切片中有两个概念：
- 一是<code>len</code>长度，
- 二是<code>cap</code>容量，</p>

<p>长度是指已经被赋过值的最大下标+1，可通过内置函数<code>len()</code>获得。容量是指切片目前可容纳的最多元素个数，可通过内置函数<code>cap()</code>获得。切片是引用类型，因此在当传递切片时将引用同一指针，修改值将会影响其他的对象。</p>

<pre><code class="language-go">SliceType = &quot;[&quot; &quot;]&quot; ElementType .
// 例如：
var a []int
</code></pre>

<p><strong>没有初始化的<code>slice</code>为<code>nil</code>。</strong></p>

<p>切片(slice)对数组进行封装，实际上，切片可以看成大小可以动态变化的数组，这一点类似C++中<code>std::vector</code>。就像<code>std::vector</code>在实际C++编程中大量使用一样，Go中大多数的数组编程都是通过切片完成，而不是简单数组。</p>

<p>一般来说，有两种方式来初始化切片：
- 通过数组</p>

<pre><code class="language-go">var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
var mySlice []int = myArray[:5]
</code></pre>

<ul>
<li>通过make：
<code>go
// make([]T, length, capacity)
func make([]T, len, cap) []T
</code></li>
</ul>

<p>创建一个初始长度为<code>5</code>，容量为<code>10</code>为切片，切片的每个元素都为<code>0</code>：</p>

<pre><code class="language-go">slice1 := make([]int, 5, 10)
</code></pre>

<p>创建一个长度为<code>5</code>的切片，并初始化切片的每个元素：</p>

<pre><code class="language-go">slice2 := []int{1, 2, 3, 4, 5}
</code></pre>

<p>对于切片，最重要的特点就是长度是可变的：</p>

<pre><code class="language-go">slice2 := []int{1, 2, 3, 4, 5}
fmt.Println(&quot;slice:&quot;, slice2)
 
slice2 = append(slice2, 6)
fmt.Println(&quot;slice:&quot;, slice2)
</code></pre>

<p>输出：</p>

<pre><code class="language-go">slice: [1 2 3 4 5]
slice: [1 2 3 4 5 6]
</code></pre>

<p>函数<code>append</code>是<code>GO</code>专门为切片增加元素而提供的一个内建函数。</p>

<p>切片持有对底层数组的引用，如果你将一个切片赋值给另一个，二者都将引用同一个数组。如果函数接受一个切片作为参数，那么其对切片的元素所做的改动，对于调用者是可见的，好比是传递了一个底层数组的指针。</p>

<pre><code class="language-go">func (f *File) Read(b []byte) (n int, err error)
</code></pre>

<p>这个<code>os.File</code>的<code>Read</code>方法，它接受一个切片参数，切片中的长度已经设定了要读取的数据的上限。对于<code>C/C++</code>，需要同时提供一个缓冲区的指针，和缓冲区的大小：</p>

<pre><code class="language-c">int read(File* f, char* buf, int len)
</code></pre>

<p>从这里可以看到，GO的写法要简单一些。</p>

<h2 id="切片的切片操作">切片的切片操作</h2>

<p>切片类型重要的操作就是<strong>切片</strong>，使用一个半开的区间，使用两个索引指定要切片的范围<code>([lo, hi]两个索引是前闭后开的)</code>。</p>

<pre><code class="language-go">s := []byte{'a', 'd',  's', 'f', 'g', 'h'}
// s[1:4] == []byte{'d', 's', 'f' }
</code></pre>

<p>使用时要注意前闭后开的性质，切片后的长度为<strong>hi-lo</strong>。</p>

<p>特别需要注意的是：<strong>切片操作返回的切片与原切片共享存储。切片操作不不会复制原切片的数据，而是将新的切片的指针指向原切片的某个元素。</strong></p>

<h2 id="copy">copy</h2>

<p><code>copy</code>方法的声名为:</p>

<pre><code class="language-go">func copy(dst, src []T) int
</code></pre>

<p><code>copy</code>方法还可以处理共享相同底层数组的切片，处理<code>dst</code>和<code>src</code>的重叠问题。另外当<code>dst</code>和<code>src</code>的长度不一样时，只会拷贝较短的部分。理解这一部分这也是很重要的:</p>

<pre><code class="language-go">sli := []int{1,2,3,4,5}
t := []int{11,21,31,41,5,6,7,8,9}
copy(sli, t) // sli=[11,21,31,41,5]
// copy(t, sli) // t=[1,2,3,4,5,6,7,8,9]
</code></pre>

<h2 id="append">append</h2>

<p><code>append</code>方法用于对切片追加元素。<code>append</code>方法的签名为:</p>

<pre><code class="language-go">func append(s []T, x ...T) []T
</code></pre>

<p>方法想<code>s</code>的结尾追加元素<code>x</code>，如果<code>len</code>小于<code>cap</code>则直接追加，如果<code>capacity</code>不够则会自动扩大(2倍)切片。</p>

<p><code>append</code>可以用来追加元素也可以用来将一个切片追加到另一个切片后面。这里使用<code>...</code>操作符(expand operator)</p>

<pre><code class="language-go">append(t, 100, 200)
append(t, sli...)
</code></pre>

<p>需要注意的是，<code>append</code>会返回一个<strong>新的切片</strong>而不是修改原来的切片(试验了一下，append返回的切片不是共享存储)，可以通过append方法的签名看出。</p>

<p>切片共享存储可能存在问题是，如果一个很大的切片<code>切</code>出一小片保存在一个新切片，而这个大切片这已经不需要了，但是由于小切片保留了这些引用，所以<code>GC Collector</code>还不能回收这一个大切片。如果真的遇到这样场景推荐<strong>把这小块切片复制出来</strong>。</p>

<h2 id="切片-数组-的遍历">切片(数组)的遍历</h2>

<p>在go语言中，遍历切片或者数组，有两种方式：
- 传统方式：</p>

<pre><code class="language-go">for i := 0; i &lt;len(mySlice); i++ {
  fmt.Println(&quot;mySlice[&quot;, i, &quot;] =&quot;, mySlice[i])
}
</code></pre>

<ul>
<li>使用range表达式
<code>range</code>表达式有两个返回值，第一个是<strong>索引</strong>，第二个是元素的<strong>值</strong>：
<code>go
for i, v := range mySlice {
fmt.Println(&quot;mySlice[&quot;, i, &quot;] =&quot;, v)
}
</code></li>
</ul>

<p>使用<code>range</code>让代码更加简洁，所以在go编程中也更加常用。</p>

<h2 id="参考文献">参考文献</h2>

<ul>
<li><a href="https://blog.go-zh.org/go-slices-usage-and-internals">切片的本质</a></li>
<li><a href="http://www.cnblogs.com/hustcat/p/4002707.html">数组和切片</a></li>
<li><a href="http://blog.wuxu92.com/array-and-slice-in-golang/">slice</a></li>
<li><a href="https://golang.org/doc/effective_go.html#arrays">go array</a></li>
<li><a href="https://gobyexample.com/slices">slices</a></li>
<li><a href="https://golang.org/doc/effective_go.html#arrays">array and slice</a></li>
</ul>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/go-pool/">go-sync.pool</a></li>
        
        <li><a href="/post/heling-go-36-notes/">go基础的一些概念</a></li>
        
        <li><a href="/travel/travel-life-30/">30岁我人生的一个转折点</a></li>
        
        <li><a href="/post/can-not-create-foreign-key-reasons/">Mysql无法创建外键原因总结</a></li>
        
        <li><a href="/archives/">归档</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="http://emacsvi.com/tags/go">go</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://emacsvi.com">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://emacsvi.com/post/filecoin-lotus-cmd/" title="lotus命令备忘">lotus命令备忘</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-mapstructure-json/" title="go之中mapstructure的使用">go之中mapstructure的使用</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-pprof/" title="go的工具pprof使用注意">go的工具pprof使用注意</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-panic-defer-recover/" title="go异常处理panic-defer-recover的使用">go异常处理panic-defer-recover的使用</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-channel-bugs/" title="go有关channel的注意事项">go有关channel的注意事项</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-create-markdown-program/" title="创建博文markdown写了一个go程序来减少劳动力">创建博文markdown写了一个go程序来减少劳动力</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-pipeline/" title="Go 译文之如何构建并发 Pipeline">Go 译文之如何构建并发 Pipeline</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-context-translate/" title="Go 译文之通过 context 实现并发控制">Go 译文之通过 context 实现并发控制</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-init-flow/" title="go-init初始化顺序">go-init初始化顺序</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/post/go-map-deepcopy/" title="go-map深度拷贝实现">go-map深度拷贝实现</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://emacsvi.com/categories/docker/">docker(2)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/etcd/">etcd(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/filecoin/">filecoin(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/go/">go(35)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/linux/">linux(2)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/mac/">mac(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/markdown/">markdown(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/%E6%8A%80%E6%9C%AF/">技术(1)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/%E6%97%85%E8%A1%8C/">旅行(3)</a>
    </li>
    
    <li>
        <a href="http://emacsvi.com/categories/%E6%B5%81%E9%87%91%E5%B2%81%E6%9C%88/">流金岁月(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="http://emacsvi.com/tags/cmds/">cmds</a>
    
    <a href="http://emacsvi.com/tags/docker/">docker</a>
    
    <a href="http://emacsvi.com/tags/docker-compose/">docker-compose</a>
    
    <a href="http://emacsvi.com/tags/etcd/">etcd</a>
    
    <a href="http://emacsvi.com/tags/filecoin/">filecoin</a>
    
    <a href="http://emacsvi.com/tags/go/">go</a>
    
    <a href="http://emacsvi.com/tags/linux/">linux</a>
    
    <a href="http://emacsvi.com/tags/mac/">mac</a>
    
    <a href="http://emacsvi.com/tags/markdown/">markdown</a>
    
    <a href="http://emacsvi.com/tags/mongodb/">mongodb</a>
    
    <a href="http://emacsvi.com/tags/mysql/">mysql</a>
    
    <a href="http://emacsvi.com/tags/sql/">sql</a>
    
    <a href="http://emacsvi.com/tags/supervisord/">supervisord</a>
    
    <a href="http://emacsvi.com/tags/websocket/">websocket</a>
    
    <a href="http://emacsvi.com/tags/%E5%A4%87%E5%BF%98/">备忘</a>
    
    <a href="http://emacsvi.com/tags/%E6%8A%80%E6%9C%AF/">技术</a>
    
    <a href="http://emacsvi.com/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="#" title="Android Gradle权威指南">Android Gradle权威指南</a>
        </li>
        
        <li>
            <a target="_blank" href="#" title="常用开发工具CDN镜像">常用开发工具CDN镜像</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://emacsvi.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="http://emacsvi.com">李伟的博客 By emacsvi</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.emacsvi.com/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        
        (function () {
            $("pre code").parent().addClass("line-numbers")
        }());

        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>







</body>
</html>
